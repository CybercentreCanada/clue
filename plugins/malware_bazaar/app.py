"""Malware Bazaar

Team: CCCS

Status: In Development

This plugin interfaces with malware bazaar to check selectors against known malicious signatures.
"""

import json
import os
from typing import Any, Union

import requests
from clue.common.exceptions import (
    ClueException,
    InvalidDataException,
    NotFoundException,
    TimeoutException,
    UnprocessableException,
)
from clue.common.logging import get_logger
from clue.models.network import Annotation, QueryEntry
from clue.plugin import CluePlugin
from clue.plugin.utils import Params
from pydantic_core import Url

logger = get_logger(__file__)

CLASSIFICATION = os.environ.get("CLASSIFICATION", "TLP:CLEAR")  # Classification of this service
API_URL = os.environ.get("API_URL", "https://mb-api.abuse.ch/api/v1")  # override in case of mirror
FRONTEND_URL = os.environ.get("FRONTEND_URL", "https://bazaar.abuse.ch/browse.php")  # override in case of mirror

# verify can be boolean or path to CA file
verify: Union[str, bool] = str(os.environ.get("MB_VERIFY", "true")).lower()
if verify in ("true", "1"):
    verify = True
elif verify in ("false", "0"):
    verify = False
VERIFY = verify

# Mapping of type names to external systems "type" names

TYPE_MAPPING = {"md5": "md5", "sha1": "sha1", "sha256": "sha256"}

if (environ_map := os.environ.get("TYPE_MAPPING", None)) is not None:
    TYPE_MAPPING = json.loads(environ_map)


def build_result(type_name: str, value: str, count: int, raw_data: Any = None) -> QueryEntry:
    "Build a query entry with the specified values"
    return QueryEntry(
        classification=CLASSIFICATION,
        link=Url(f"{FRONTEND_URL}?search={type_name}%3A{value}"),
        count=count,
        annotations=[],
        raw_data=raw_data,
    )


def enrich(type_name: str, value: str, params: Params, *args) -> list[QueryEntry]:  # noqa: ANN002, C901
    "enrich the given type"
    # Invalid types must either be ignored, or return a 422
    tn = TYPE_MAPPING.get(type_name)
    if tn is None:
        raise InvalidDataException(
            message=f"Type name `{type_name}` is invalid. Valid types are: {', '.join(TYPE_MAPPING.keys())}"
        )

    search_key = type_name
    if type_name in ("md5", "sha1", "sha256"):
        search_key = "hash"

    if search_key == "hash" and len(value) not in (32, 40, 64):
        raise UnprocessableException(message="Invalid hash provided. Require md5, sha1 or sha256")

    session = requests.Session()
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }
    query = {
        "hash": "get_info",
        "imphash": "get_imphash",
        "tlsh": "get_tlsh",
    }[search_key]

    data = {
        "query": query,
        search_key: value,
        "limit": params.limit,
    }

    try:
        rsp = session.post(f"{API_URL}/", data, headers=headers, verify=VERIFY, timeout=params.max_timeout)
    except requests.exceptions.Timeout as e:
        raise TimeoutException("Malware Bazaar failed to respond in time.", cause=e)

    # MB should always return a 200, even on error.
    if rsp.status_code != 200:
        raise ClueException("Unknown error submitting data to upstream.")

    rsp_json: dict[str, Any] = rsp.json()
    query_status = rsp_json.get("query_status")
    if query_status in ("no_result", "hash_not_found"):
        raise NotFoundException("No result found")

    elif query_status != "ok":
        # any other error, just return a generic error code
        raise InvalidDataException(f"Nonstandard error from Malware Bazaar: {query_status}")

    results: list[QueryEntry] = []

    # for hashes, we expect a single result back and can provide more details through enrichment
    response_data: list[dict[str, Any]] = rsp_json.get("data", [])
    for entry in response_data:
        if not isinstance(entry, dict):
            continue

        result = build_result(
            tn, value, int(entry.get("intelligence", {}).get("uploads", 1)), response_data if params.raw else None
        )

        if not params.annotate:
            continue

        if signature := entry.get("signature"):
            result.annotations.append(
                Annotation(
                    analytic="Malware Bazaar - Attribution",
                    type="context",
                    value=signature,
                    summary=f"File has been attributed to the following Malware Family: {signature}",
                    confidence=1,
                )
            )

        # set malicious if any vendor flags as malicious.
        confidence = 0.0
        vendors_map: dict[str, Any] = {}
        for analytic, intel in entry.get("vendor_intel", {}).items():
            # vendor_intel is not consistent and contains some entries that are dicts and others that are lists
            if not isinstance(intel, list):
                intel = [intel]

            for i in intel:
                if not isinstance(i, dict):
                    continue

                # this is a very dirty check...
                verdict = None
                m = i.get("detection") or i.get("verdict") or i.get("status") or i.get("detections")
                if isinstance(m, list):
                    m = "|".join(m)

                family = i.get("malware_family")
                if (m and ("malicious" in m.lower() or "malware" in m.lower())) or family:
                    verdict = "malicious"
                elif m and "suspicious" in m.lower():
                    verdict = "suspicious"

                if verdict:
                    vendors_map.setdefault(verdict, set())

                    confidence = max(confidence, float(i.get("confidence", 1)))

                    vendors_map[verdict].add(analytic)

        for verdict, vendors_list in vendors_map.items():
            vendors = ", ".join(vendors_list)
            annotation = Annotation(
                analytic="Malware Bazaar - Vendor Intel",
                type="opinion",
                value=verdict,
                quantity=len(vendors_list),
                summary=f"{len(vendors_list)} vendors found this file to be {verdict}: {vendors}",
                confidence=confidence,
                link=Url(f"{FRONTEND_URL}?search={type_name}%3A{value}"),
            )

            result.annotations.append(annotation)

        results.append(result)

    return results


plugin = CluePlugin(
    app_name=os.environ.get("APP_NAME", "malware-bazaar"),
    classification=CLASSIFICATION,
    enable_apm=False,
    enable_cache=True,
    enrich=enrich,
    supported_types={tname for tname in TYPE_MAPPING},
    logger=logger,
)
